The basic concept of how the enemies works in the game is the following. The script EnemyManager is in control of all spawning of the enemies of the game except of the dragon. In the Unity scene there are placed multiple points called spawn points that are used by the EnemyManager to place the enemies in random predefined locations in a manner that the player would not see the enemies spawning. There is two kind of spawn points, the others are meant to spawn enemies during normal game play and the others to spawn enemies when the player in engaged in the fight with the dragon. The EnemyManager also handles what type of enemies spawns and how many there are spawned on the scene depending if the player is fighting with the dragon or not. Each 10 seconds the maximum number of enemies on the map is increased by one to rise the difficulty over time.

When an enemy is spawned there is attached two scripts in each enemy except the dragon. On of the scripts is the logic of the enemy, called EnemyLogic. I controls the behaviour of the enemy. How much health it has, from how far it can attack or loot, what is the status of the enemy (looting or attacking or neither one) etc etc. It handles the hits it takes when a gun shoots him and also deals damage to the player and grabs loot from the chest. The logic contains also an interest rate that controls is the enemy's target the player or the chest, depending of the type of the enemy and of the distance from the player this can differ between different kinds of enemies.

The enemy logic only decides what is the enemy's current target and uses the navigation script EnemyNavigation to search a path and move the game object to the desired target. The navigation part uses an Unity library called "A* Pathfinding Project" found in http://arongranberg.com/astar/ . It creates a grid based on the terrain of the scene and checks what areas are traversable by the inclination of the terrain and of the tags placed on the game objects. In our case we decided that all tagged as "obstacle" are zones that are untraversable so the AI can find it's way to the target dodging these objects. The basic idea is that the AI does a A* seek on the graph and starts follow that shortest path one node at the time until it has reached the target, there is a threshold when the path is defined as done. For example we have set that the path is done when the distance from the target is under 0.7 game distance units.

The pathfinding works surprisingly well but it does not come without problems. The game has a pretty big open world with many obstacles and the enemies has to pathfind all the time no matter where they are in the map. With very large enemy count or with a more dense navigation grid at some point performance becomes the issue. In our game it still works but if we would want even more accurate pathfinding hiccups would start to show up. This could be solved by replacing the graph grid with a navmesh which is a navigation grid made by using the terrains own shapes, too bad this feature is only in the pro version of the library so it was not an option for this project.

The dragon and its behaviour has been separated from the rest of the enemies since it's actions and behaviour are totally unique compared to the other enemies. The dragon's lair is covered with different kind of triggers to control the behaviour of the dragon fight. All the triggers sends their collision detections to the script TriggerHandler that evaluates the collisions and depending of which trigger did send the message will do some actions to the dragon. For example when the player enters close to the minigun the trigger detects it and sends the message to the handler and the handler tells the dragon to fly to he's lair. Also during the dragon fight other triggers checks if the player tries to escape and if he does so the trigger handler tells the dragon to instantly kill the player.

The Dragon scripts has the control of the dragon and he's actions. It keeps up a set of different states such as flying, landing, breathing fire, fighting and so on. Depending of the state combinations the dragon performs different kind of actions such as kill the player instantly, idles for a moment, flies around and patrols.

The Dragon and the EnemyLogic both uses the services provided by the GameManager and the RagdollManager. Both uses the RagdollManager for the same purpose, when the enemy object dies the RagdollManager returns a ragdoll corresponding the enemy that has died and replaces the enemy with the ragdoll. The GameManager keeps up all kind of statistics of the game as also references to the player, dragon and so on. The enemies uses the GameManager to add points when they die and also to retrieve information about the players health and to deal damage to the player.