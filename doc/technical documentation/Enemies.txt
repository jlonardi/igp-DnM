The basic concept of how the enemies works in the game is the following. The script EnemyManager is in control of all spawning of the enemies of the game except of the dragon. In the Unity scene there are placed multiple points called spawn points that are used by the EnemyManager to place the enemies in random predefined locations in a manner that the player would not see the enemies spawning. There is two kind of spawn points, the others are meant to spawn enemies during normal game play and the others to spawn enemies when the player in engaged in the fight with the dragon. The EnemyManager also handles what type of enemies spawns and how many there are spawned on the scene depending if the player is fighting with the dragon or not. Each 10 seconds the maximum number of enemies on the map is increased by one to rise the difficulty over time.

When an enemy is spawned there is attached two scripts in each enemy except the dragon. On of the scripts is the logic of the enemy, called EnemyLogic. I controls the behaviour of the enemy. How much health it has, from how far it can attack or loot, what is the status of the enemy (looting or attacking or neither one) etc etc. It handles the hits it takes when a gun shoots him and also deals damage to the player and grabs loot from the chest. The logic contains also an interest rate that controls is the enemy's target the player or the chest, depending of the type of the enemy and of the distance from the player this can differ between different kinds of enemies.

The enemy logic only decides what is the enemy's current target and uses the navigation script EnemyNavigation to search a path and move the game object to the desired target. The navigation part uses an Unity library called "A* Pathfinding Project" found in http://arongranberg.com/astar/ . It creates a grid based on the terrain of the scene and checks what areas are traversable by the inclination of the terrain and of the tags placed on the game objects. In our case we decided that all tagged as "obstacle" are zones that are untraversable so the AI can find it's way to the target dodging these objects. The basic idea is that the AI does a A* seek on the graph and starts follow that shortest path one node at the time until it has reached the target, there is a threshold when the path is defined as done. For example we have set that the path is done when the distance from the target is under 0.7 game distance units.

The pathfinding works surprisingly well but it does not come without problems. The game has a pretty big open world with many obstacles and the enemies has to pathfind all the time no matter where they are in the map. With very large enemy count or with a more dense navigation grid at some point performance becomes the issue. In our game it still works but if we would want even more accurate pathfinding hiccups would start to show up. This could be solved by replacing the graph grid with a navmesh which is a navigation grid made by using the terrains own shapes, too bad this feature is only in the pro version of the library so it was not an option for this project.